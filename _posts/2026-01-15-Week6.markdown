---
layout: post
title:  "Week 6"
categories: jekyll update
---

## Combat System & Enemy Behavior

To improve code clarity, old unused scripts for the swords were removed.
Furthermore, the hit zone and opponent classes were made abstract in order to inherit them and avoid code duplication.

The behavior of the melee skeleton has been revised.
As soon as it reaches a nav point, the skeleton turns toward the center of the room to look around.
This increases the probability that the player will be seen.
If the skeleton is hit by an arrow while walking, it now stops and turns in the direction the arrow came from.

These changes are preparations to enable additional types of opponents.
We are currently working on adding a ranged skeleton.
A corresponding prefab has already been created, and the corresponding animator controller that uses the necessary animations is currently being created.

The number of error messages caused by the RuntimeNavMeshBuilder has been drastically reduced.
To achieve this, models that are irrelevant for the movement freedom of opponents have been moved to other layers.
For models that are relevant, the NavMeshObstacle component has been moved to the correct object.
This led to a more reliable construction of the NavMesh.
Now only TextMesh Pro meshes cause error messages at startup, even though they are located in their own UI layer, which should be ignored by the RuntimeNavMeshBuilder.

By Rene Tischler

## Animations

Movement and Attack animations of the opponents and the player now scale with their corresponding factors given in the stats. Additionally, the player animations have been made generally slower as they were looking whimsical, especially when sprinting. The combat animation layer for the player now also uses an avatar mask so that it only applies to the relevant parts of the player model. The bow and quiver models have been added to the player prefab and become visible only when in the corresponding firing mode. Some setup work has been done to use the proper bow animations when the bow is in use, however a new shooting mechanic is going to be required to make proper use of the draw and release animations where the player first has to draw the bow, and the shot is only made on release. As such, the bow animations are still unfinished.

By Moritz Mahling

## Items

Extended the logic for item definitions such that we can define items that
affect players stats. As an example, added an item ('rune of swiftness',
currently without proper assets) that makes the player faster.

## UI

The ui for player upgrades now shows the effect of an upgrade.
For example, when selecting the 'Agility' stat, a ui element
shows that upgrading the stat increases increases movement speed
by a factor xy.

<img width="300" alt="preview of upgrade effects" src="{{site.imgpath}}/upgrade-preview.png">

The ui for items now shows a description of the item and its effects
(if it has any). E.g. for the 'rune of swiftness', it shows the player
that the item increases movement speed by some factor.

<img width="300" alt="inventory with item information" src="{{site.imgpath}}/inventory-item-info.png">

For the final game, we have to add proper sprites and define display names
for the stats that are displayed as seen above
(which simply use enum identifiers currently).

## Under-the-hood code improvements

### Scene initialization

Until now, all initialization logic of a level was spread out across the
`Start`-methods of multiple scripts, including Dungeon creation, reading
game state files, computation of player stats.
This is not robust, as the order in which these methods are called is
unspecified and might not even happen sequentially.

I implemented a component that triggers a UnityEvent when its start-method is
called. For this event, we can configure in the editor which setup-methods
to call in which order. With that we can configure the initialization process
in one place.

### Player Input

Switched to the new input system of unity with a mix of polling and callbacks.
Configured the action maps for the player and the ui to match the mappings that
were previously hardcoded.
This step enables us to easily reconfigure the input bindings and optionally
define different handling of tapping or holding keys.

### UI

For the UI, I refactored our implementation of the ui state machine to be more
robust and configurable/extensible. Now, we can specify a set of ui elements and
for each, in which states it should be enabled.
Further, cursor lock can be configured for each ui state.
In addition, I added the possibility to configure enabling/disabling of input
action maps and individual actions depending on the ui state.

By Axel Schneewind

## Boss Room

The Door is functional and has animation, next steps are some improvments of the material, parralel to integrating it into the dungeon creation.

![](images/boss-door-unity-1.png){: height="250ex"}

By David Ruff